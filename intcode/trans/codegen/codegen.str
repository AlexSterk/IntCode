module codegen

imports
	signatures/intcode-sig
	desugar/-
	
rules
  		
  compile-program: p@Program(stmts) -> $[[x],[memory]]
  	where 
  		size := <program-size> p;
  		(x, stck, scp) := <compile-stmts(|size, [])> stmts;
  		memory := <create-memory> (size, stck)
  		
  compile-stmts(|stck, scp): [] -> ("99", stck, scp)
  compile-stmts(|stck, scp): [h] -> ($[[s],99], nstck, nscp)
  	where (s, nstck, nscp) := <compile-stmt(|stck, scp)> h
  compile-stmts(|stck, scp): [h | t] -> ($[[s],[s2]], nnstck, nnscp)
  	where 
  	(s, nstck, nscp) := <compile-stmt(|stck, scp)> h;
  	(s2, nnstck, nnscp) := <compile-stmts(|nstck, nscp)> t
  
  compile-stmt(|stck, scp): Print(Int(n)) -> ($[104,[n]], stck, scp)
  compile-stmt(|stck, scp): Print(e) -> (s2, n, scp)
  	where
  		(s, l, n) := <compile-exp(|stck, scp)> e;
  		s2 := <empty-concat> (s, $[4,[l]])
  		
  compile-stmt(|stck, scp): Assign(Var(x), e) -> (s, stck, scp)
  	where
  		<fetch(?(x,l);debug)> scp;
  		(s1, arg1, nstck) := <compile-exp(|stck, scp)> e;
  		m := <match-mode> e;
  		s := <empty-concat> (s1, $[1[m]01,[arg1],[0],[l]])
  compile-stmt(|stck, scp): Assign(Var(x), e) -> (s, n, [(x, n)|scp])
  	where
  		(s, l, n) := <compile-exp(|stck, scp)> BinExp(Plus(), Int("0"), e)
  		
  compile-exp(|stck, scp): BinExp(op, e1, e2) -> (s, arg3, arg3)
  	where
  	  o := <match-opcode> op;
  	  m1 := <match-mode> e1;
  	  m2 := <match-mode> e2;
  	  (s1, arg1, nstck) := <compile-exp(|stck, scp)> e1;
  	  (s2, arg2, nnstack) := <compile-exp(|nstck, scp)> e2;
  	  opcode := <ltrim-chars(?'0')> $[[m2][m1]0[o]];
  	  prev := <empty-concat> (s1, s2);
  	  arg3 := <inc> stck;
  	  s := <empty-concat> (prev, $[[opcode],[arg1],[arg2],[arg3]])
  	  
  compile-exp(|stck, scp): Int(n) -> ("", n, stck)
  compile-exp(|stck, scp): In() -> ($[3,[nstck]], nstck, nstck)
  	where nstck := <inc> stck
  compile-exp(|stck, scp): VarRef(x) -> ("", l, stck)
  	where
  		(_, l) := <fetch-elem(?(x, _))> scp
  	  
  match-opcode: Plus() -> "1"
  match-opcode: Times() -> "2"
  
  match-mode: Int(_) -> "1"
  match-mode: _ -> "0"
  
//  compile-exp(|stck, scp): Add(Int(n1), Int(n2)) -> ($[1101,[n1],[n2],[p]], p)
//  	where p := <inc> stck
//  compile-exp(|stck, scp): Add(Int(n1), e) -> ($[[s],101,[n1],[n2],[p]], p)
//  	where 
//  		(s, n2) := <compile-exp(|stck, scp)> e;
//  		p := <inc> n2
//  compile-exp(|stck, scp): Add(e, Int(n2)) -> ($[[s],1001,[n1],[n2],[p]], p)
//  	where 
//  		(s, n1) := <compile-exp(|stck, scp)> e;
//  		p := <inc> n1
//  compile-exp(|stck, scp): Add(e1, e2) -> ($[[s1],[s2],1,[n1],[n2],[p]], p)
//  	where 
//  		(s1, n1) := <compile-exp(|stck, scp)> e1;
//  		(s2, n2) := <compile-exp(|n1)> e2;
//  		p := <inc> n2
//  		
//  compile-exp(|stck, scp): Mul(Int(n1), Int(n2)) -> ($[1102,[n1],[n2],[p]], p)
//  	where p := <inc> stck
//  compile-exp(|stck, scp): Mul(Int(n1), e) -> ($[[s],102,[n1],[n2],[p]], p)
//  	where 
//  		(s, n2) := <compile-exp(|stck, scp)> e;
//  		p := <inc> n2
//  compile-exp(|stck, scp): Mul(e, Int(n2)) -> ($[[s],1002,[n1],[n2],[p]], p)
//  	where 
//  		(s, n1) := <compile-exp(|stck, scp)> e;
//  		p := <inc> n1
//  compile-exp(|stck, scp): Mul(e1, e2) -> ($[[s1],[s2],2,[n1],[n2],[p]], p)
//  	where 
//  		(s1, n1) := <compile-exp(|stck, scp)> e1;
//  		(s2, n2) := <compile-exp(|n1)> e2;
//  		p := <inc> n2
  		
  program-size: Program(stmts) -> <foldl(addi)> (x, 0)
  	where x := <collect-all(get-size, conc)> stmts
  
  get-size: Print(_) -> 2
  get-size: BinExp(_, _, _) -> 4
  get-size: In() -> 2
  get-size: Assign(_, _) -> 4
  get-size : VarRef(_) -> 0
//  get-size: If(_, _, _) -> 3

  create-memory: (s, s) -> "0"
  create-memory: (s, c) -> $[0,[<create-memory> (s, <subti> (c, 1))]]
  
  empty-concat: ("",s) -> s
  empty-concat: (s,"") -> s
  empty-concat: (s1,s2) -> $[[s1],[s2]]